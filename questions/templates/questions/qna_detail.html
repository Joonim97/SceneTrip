{% extends 'base.html' %}
{% block title %}
  {{ question.title }} - 상세 페이지
{% endblock %}
{% block content %}
<div class="container mt-5">
  <h2 id="question-title">{{ question.title }}</h2>
  <p>
    작성자: {{ question.author }}
    <!-- 수정 및 삭제 버튼 -->
    <button id="edit-btn" class="btn btn-warning">수정</button>
    <button id="delete-btn" class="btn btn-danger">삭제</button>
  </p>
  <p>작성일: {{ question.created_at }}</p>
  <!-- 이미지 표시 -->
  <div class="mb-3">
    <h5>첨부된 이미지</h5>
    <div class="row">
      {% for image in question.images %}
        <div class="col-md-4 mb-3">
          <img src="{{ image.question_images }}" class="img-fluid" alt="첨부 이미지">
        </div>
      {% endfor %}
    </div>
  </div>
  <div class="mb-3">
    <h5>내용</h5>
    <p id="question-content">{{ question.content }}</p> <!-- 기존 질문 내용을 표시 -->
    <!-- 수정 모드에서는 이 폼을 보여줌 -->
    <div id="edit-form" style="display: none;">
      <div class="mb-3">
        <label for="edit-title">제목 수정</label>
        <input type="text" id="edit-title" class="form-control" value="{{ question.title }}">
      </div>
      <div class="mb-3">
        <label for="edit-content">내용 수정</label>
        <textarea id="edit-content" class="form-control" rows="3">{{ question.content }}</textarea>
      </div>
      <div class="mb-3">
        <label for="edit-images">이미지 수정</label>
        <input type="file" id="edit-images" name="images" class="form-control" accept="image/*" multiple>
      </div>
      <!-- 기존 이미지를 삭제할 수 있는 체크박스 -->
      <div class="mb-3">
        <h6>기존 이미지 삭제</h6>
        <div class="row">
          {% for image in question.images %}
            <div class="col-md-4 mb-3">
              <img src="{{ image.question_images }}" class="img-fluid" alt="첨부 이미지">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" value="{{ image.id }}" id="delete-image-{{ image.id }}">
                <label class="form-check-label" for="delete-image-{{ image.id }}">
                  삭제
                </label>
              </div>
            </div>
          {% endfor %}
        </div>
      </div>
      <button id="save-edit-btn" class="btn btn-primary mt-2">저장</button>
      <button id="cancel-edit-btn" class="btn btn-secondary mt-2">취소</button>
    </div>
  </div>
  <!-- 댓글 목록 -->
  <div class="mb-3">
    <h5>댓글</h5>
    {% if question.comments %}
      {% for comment in question.comments %}
        <div class="comment mb-3">
          <p>
            <strong>{{ comment.user_nickname }}:</strong> {{ comment.content }}
          </p>
          <p>
            <small>{{ comment.created_at }}</small>
          </p>
        </div>
      {% endfor %}
    {% else %}
      <p>댓글이 없습니다.</p>
    {% endif %}
  </div>
</div>
<!-- 댓글 작성 -->
<div class="mb-3">
  <h5>댓글 작성</h5>
  <form id="comment-form" method="POST">
    <textarea id="comment-content" class="form-control" rows="3" placeholder="댓글을 입력하세요"></textarea>
    <button type="submit" class="btn btn-primary mt-2">댓글 작성</button>
  </form>
</div>
</div>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const accessToken = localStorage.getItem('access_token');
<<<<<<< HEAD
=======

    if (!accessToken) {
      alert('로그인한 사용자만 이용 가능합니다.');
      window.location.href = '/api/accounts/login-page/';  // 로그인 페이지로 리다이렉트
      return;  // 이후 코드를 실행하지 않도록 return
    }

    fetch("/api/accounts/user-info/", {
      method: "GET",
      headers: {
        'Authorization': `Bearer ${accessToken}`,  // 변수로 가져온 토큰 사용
        'Content-Type': 'application/json'
      }
    })
    .then(response => {
      if (!response.ok) {
        if (response.status === 401) {  // 토큰 만료에 따른 리프레시
          return fetch("/api/accounts/token/refresh/", {
            method: "POST",
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 'refresh': localStorage.getItem('refresh_token') })
          })
          .then(res => {
            if (!res.ok) {
              throw new Error('토큰 갱신 실패');
            }
            return res.json();
          })
          .then(data => {
            // 새로 발급된 액세스 토큰 저장
            localStorage.setItem('access_token', data.access);
            return fetch("/api/accounts/user-info/", {
              method: "GET",
              headers: {
                'Authorization': `Bearer ${data.access}`,  // 새로운 액세스 토큰 사용
                'Content-Type': 'application/json'
              }
            });
          });
        } else {
          throw new Error('인증 실패');
        }
      }
      return response.json();
    })
    .then(data => {
      // 로그인하지 않은 사용자의 경우 처리
      if (data.nickname !== '{{ question.author }}') {
        // 로그인했지만 작성자가 아닌 경우
        alert('작성자만 들어갈 수 있습니다.');
        window.location.href = '/api/questions/qna/page/';  // qna 페이지로 리다이렉트
      }
    })
    .catch(error => {
      console.error('에러 발생:', error);
      localStorage.removeItem('access_token');
      localStorage.removeItem('refresh_token');
    });
  }
);
>>>>>>> feat/frontaccount
  // 수정 버튼 클릭 시 수정 폼 표시
  document.getElementById('edit-btn').addEventListener('click', function() {
    document.getElementById('question-content').style.display = 'none'; // 기존 내용 숨기기
    document.getElementById('question-title').style.display = 'none'; // 기존 제목 숨기기
    document.getElementById('edit-form').style.display = 'block'; // 수정 폼 표시
  });
  // 수정 취소 버튼 클릭 시 원래 내용 표시
  document.getElementById('cancel-edit-btn').addEventListener('click', function() {
    document.getElementById('question-content').style.display = 'block'; // 기존 내용 표시
    document.getElementById('question-title').style.display = 'block'; // 기존 제목 표시
    document.getElementById('edit-form').style.display = 'none'; // 수정 폼 숨기기
  });
  document.getElementById('save-edit-btn').addEventListener('click', function() {
    const editedTitle = document.getElementById('edit-title').value;
    const editedContent = document.getElementById('edit-content').value;
    const formData = new FormData();
    formData.append('title', editedTitle);
    formData.append('content', editedContent);
    // 추가된 이미지 파일을 FormData에 추가
    const imageFiles = document.getElementById('edit-images').files;
    for (let i = 0; i < imageFiles.length; i++) {
        formData.append('images', imageFiles[i]);
    }
    // 삭제할 이미지 ID를 수집
    const deleteImages = [];
    const checkedCheckboxes = document.querySelectorAll('input[type="checkbox"]:checked');
    console.log("체크된 체크박스들:", checkedCheckboxes);
    checkedCheckboxes.forEach((checkbox) => {
        if (checkbox.value) {
            console.log("체크된 이미지 ID:", checkbox.value);
            deleteImages.push(checkbox.value);
        }
    });
    console.log("삭제할 이미지 ID들:", deleteImages);
    deleteImages.forEach(id => formData.append('delete_images', id));
    if (!accessToken) {
      alert('로그인 후 이용해주세요.');
      window.location.href = "{% url 'accounts:login_page' %}";
      return;
    }
    // PUT 요청을 통해 서버에 수정된 제목, 내용 및 이미지 전송
    fetch(`/api/questions/{{ question.questionKey }}/`, {
      method: "PUT",
      headers: {
        'Authorization': `Bearer ${accessToken}`
      },
      body: formData
    })
    .then(response => {
      if (!response.ok) {
        throw new Error('수정 실패');
      }
      return response.json();
    })
    .then(data => {
      alert('수정이 성공적으로 완료되었습니다.');
      // 삭제할 이미지가 있는 경우 DOM에서 이미지 제거
      deleteImages.forEach(imageId => {
        const imageElement = document.getElementById(`delete-image-${imageId}`).closest('.col-md-4');
        imageElement.remove();
      });
      document.getElementById('question-title').textContent = editedTitle;
      document.getElementById('question-content').textContent = editedContent;
      document.getElementById('question-title').style.display = 'block';
      document.getElementById('question-content').style.display = 'block';
      document.getElementById('edit-form').style.display = 'none';
    })
    .catch(error => {
      console.error('에러 발생:', error);
      alert('수정 중 문제가 발생했습니다.');
    });
});
  // 댓글 작성 처리
  document.getElementById('comment-form').addEventListener('submit', function(event) {
    event.preventDefault();
    const commentContent = document.getElementById('comment-content').value;
    if (!accessToken) {
      alert('로그인 후 이용해주세요.');
      window.location.href = "{% url 'accounts:login_page' %}";
      return;
    }
    fetch(`/api/questions/{{ question.questionKey }}/comments/`, {
      method: "POST",
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        content: commentContent
      })
    })
    .then(response => {
      if (!response.ok) {
        throw new Error('댓글 작성 실패');
      }
      return response.json();
    })
    .then(data => {
      alert('댓글이 성공적으로 작성되었습니다.');
      location.reload();  // 페이지 새로고침
    })
    .catch(error => {
      console.error('에러 발생:', error);
      alert('댓글 작성 중 문제가 발생했습니다.');
    });
  });
  // 글 삭제 처리
  document.getElementById('delete-btn').addEventListener('click', function() {
    if (confirm('정말로 이 글을 삭제하시겠습니까?')) {
      fetch(`/api/questions/{{ question.questionKey }}/`, {
        method: "DELETE",
        headers: {
          'Authorization': `Bearer ${accessToken}`,
        }
      })
      .then(response => {
        if (response.ok) {
          alert('삭제되었습니다.');
          window.location.href = "{% url 'questions:qna-list' %}";
        } else {
          alert('삭제 중 문제가 발생했습니다.');
        }
      });
    }
  });

</script>
{% endblock %}